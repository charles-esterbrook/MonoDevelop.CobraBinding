use Cobra.Compiler

use MonoDevelop.Ide.TypeSystem
use MonoDevelop.Ide.Gui.Content
use MonoDevelop.Projects

use ICSharpCode.NRefactory
use ICSharpCode.NRefactory.TypeSystem

namespace MonoDevelop.CobraBinding.TypeSystem

class Parser implements ITypeSystemParser, IFoldingParser
	"""
	The type system parser provides a ParsedDocument required for adding 
	information to the type system service to make the file contents available 
	for type lookup (code completion, resolving etc.).
	
	This parser also provides folds and underlines syntax errors.
	"""
	
	const TYPICAL_LINE_COUNT = 512 # 4 kB
		
	var _tabsToSpaces = false
	var _indentToken = "\t"
	
	def parse(storeAst as bool, fileName as String, content as TextReader, project as Project?) as ParsedDocument
		"""
		implements ITypeSystemParser.parse
		
		Generates folds and parses the specified file using the Cobra Parser.
		Stores the resultant AST in the ParsedDocument when storeAst is true.
		"""
		/#
		#TODO: Figure out how to get the 'tabs to spaces' and other policies'
		if project is not nil
			project = project to DotNetProject
			@help project.policies
			_tabsToSpaces = project.policies.get<of TextStylePolicy>.tabsToSpaces
			trace _tabsToSpaces
			trace project.parentSolution.policies.get<of TextStylePolicy>.tabsToSpaces
			trace project.policies.directHas<of TextStylePolicy>
		#/
		
		trace fileName
		
		# read the file content
		source = content.readToEnd
		
		# invoke Cobra Parser and visit AST
		parser = CobraParser()
		
		# the parser needs a valid compiler and backend
		compiler = Compiler(0) # verbosity = 0
		
		# TODO: Figure out why/when I need to do this
		Node.setCompiler(compiler)
		Node.typeProvider = compiler
		
		options = OptionValues()
		# TODO: Figure out what options are really necessary
		options.add("compile", true)
		options.add("back-end", "clr")
		options.add("turbo", true)
		options.add("number", "decimal")
		
		compiler.options = options
		compiler.initBackEnd
		backEnd = compiler.backEnd
		
		# TODO: review previous parsing results (if any)
		parsedFileCount = 0
		prevModule as CobraModule? = nil
		
		# Add project references
		compiler.addRunTimeRef(options)
		compiler.readSystemTypes
		
		if project <> nil
			dotNetProj = project to DotNetProject
		
			for projRef in dotNetProj.references
				for refFileName in projRef.getReferencedFileNames(ConfigurationSelector.default)
					errMsg = compiler.loadReference(refFileName, false)
					if errMsg <> nil
						trace errMsg #TODO: pass this on to MonoDevelop
		
		# initialize the parser
		parser.typeProvider = compiler
		parser.warningRecorder = compiler
		parser.errorRecorder = compiler
		parser.globalNS = compiler.globalNS
		parser.backEnd = compiler.backEnd
		
		# parse the code
		module as CobraModule? = nil
		try
			module = parser.parseSource(fileName, source)
			compiler.modules.add(module)
			
			for parserRef in parser.references #TODO: We don't have an arg parser so this loop will never be entered I believe
				compiler.loadReference(backEnd.fixLibExtension(parserRef), false)
			
		catch ex as Exception
			compiler.errors.add(SourceException(ex.message))
		
		# add folds
		parsedDoc = .parse(fileName, source) to DefaultParsedDocument #TODO? to ParsedCobraDocument?
		
		# add parsing errors
		errors = List<of Error>()
		
		for e in compiler.errors		
			errors.add(Error( _
				ErrorType.Error, e.message, e.lineNum, e.colNum))
				
		for w in compiler.warnings
			errors.add(Error( _
				ErrorType.Warning, w.message, w.lineNum, w.colNum))
			
		parsedDoc.add(errors)
		
		
		
		
		trace errors.count
		if errors.count == 0
			try
				# bind use
				for mod in compiler.modules.clone
					compiler.curModule = mod # TODO: is this necessary?
					mod.bindUse
				
				# bind inheritance
				for basicType in compiler.basicTypes
					basicType.bindInh
				compiler.objectType.bindInh
				compiler.stringType.bindInh
				compiler.dynamicType.bindInh
				compiler.passThroughType.bindInh
				compiler.voidType.bindInh
		
				for mod in compiler.modules.clone
					compiler.curModule = mod
					mod.bindInh
					
				# bind interface
				compiler.fixMemberSigs
				for basicType in compiler.basicTypes
					basicType.bindInt
				compiler.objectType.bindInt
				compiler.stringType.bindInt
				compiler.dynamicType.bindInt
				compiler.passThroughType.bindInt
				compiler.voidType.bindInt
				
				for mod in compiler.modules.clone
					compiler.curModule = mod
					mod.bindInh
					
				# compute matching base members phase
				for mod in compiler.modules
					compiler.curModule = mod
					mod.computeMatchingBaseMembers
				
				# bind implementation
				BindImplementationPhase(compiler).innerRun
				
			catch sourceEx as SourceException
				trace sourceEx.message
				parsedDoc.add(Error(ErrorType.Error, sourceEx.message))
				
		
				
		
		#doc = MonoDevelop.Ide.IdeApp.workbench.getDocument(fileName)
		if storeAst
			parsedDoc.ast = module #TODO: Use some kind of cached AST if there were parsing errors

		/# TODO? Add comment regions?
		comments = List<of Tag>()
		parsedDoc.add(comments)
		#/
		
		return parsedDoc
		
	def parse(fileName as String, content as String) as ParsedDocument
		"""
		implements IFoldingParser.parse
		
		Parse the specified file to generate folds.
		"""
		
		parsedDoc = DefaultParsedDocument(fileName)
		
		reader = StringReader(content)
		folds = List<of FoldingRegion>()
		_addFolds(_getLineInformation(reader), folds)
		
		parsedDoc.add(folds)
		
		return parsedDoc
	
	
	def _getLineInformation(reader as StringReader) as List<of LineInformation>
		
		lines = List<of String>(.TYPICAL_LINE_COUNT)
		
		line = reader.readLine
		while line <> nil
			lines.add(line)
			line = reader.readLine
			
		if lines.count > 0
			return _getLineInformation(lines)
			
		return List<of LineInformation>()
		
	def _getLineInformation(lines as List<of String>) as List<of LineInformation>
		"""
		Create a list of LineInformation objects that make it easier to 
		create folding regions.
		"""
		require
			lines.count > 0
		ensure
			result.count == lines.count
		test
			pass
		body
			info as LineInformation? = nil
			inComment = false
			inDocString = false
			docStringTag as String? = nil
			infoList = List<of LineInformation>(lines.count)
	
			for line in lines
	
				info = LineInformation(line, inComment, inDocString, docStringTag, info)
	
				if not inComment and info.opensComment
					inComment = true
				else if inComment and info.closesComment
					inComment = false
	
				if not inDocString and info.opensDocString
					inDocString = true
					docStringTag = info.docStringTag
				else if inDocString and info.closesDocString
					inDocString = false
					docStringTag = nil
	
				infoList.add(info)
				
			return infoList

	sig ClosesDelimitedBlock(info as LineInformation) as bool

	def _addFolds(infoList as List<of LineInformation>, folds as List<of FoldingRegion>)
		"""
		Adds folds to the given list of folds using the given list of line information.
		"""
		test
			source = List<of String>()
			source.add("use Foo.Namespace")
			source.add("")
			source.add("namespace Bar.Namespace")
			source.add("\tclass SomeClass")
			source.add("\t\t'''")
			source.add("\t\tDocstring text")
			source.add("\t\t'''")
			source.add("")
			source.add("\t\tdef aMethod")
			source.add("/#")
			source.add("\ta comment")
			source.add("\t\t#/")
			source.add("\t\t\t")
			source.add("\t\t\tprint 'hello world!'")
			source.add("")
			source.add("")
			
			parser = Parser()
			infoList = parser._getLineInformation(source)
			folds = List<of FoldingRegion>()
			parser._addFolds(infoList, folds)
			
			assert folds.count == 5
			
			commentBlockCount = 0
			for f in folds
				/#
				trace f.region.beginLine
				trace f.region.endLine
				#/
				if f.type == FoldType.Comment
					commentBlockCount += 1
				else
					assert f.region.endLine == 14
					
			assert commentBlockCount == 2

		test docStrings
			source = List<of String>()
			source.add("'''")
			source.add("Program docstring")
			source.add("'''")
			source.add("interface SomeInterface")
			source.add("\t'''")
			source.add("\tDocstring text for interface")
			source.add("\t'''")
			source.add("")
			source.add("\tget aProperty")
			source.add("\t\t'''")
			source.add("\t\tProperty Docstring")
			source.add("\t\t'''")
			
			parser = Parser()
			infoList = parser._getLineInformation(source)
			folds = List<of FoldingRegion>()
			parser._addFolds(infoList, folds)
			
			assert folds.count == 5
			
			commentBlockCount = 0
			for f in folds
				/#
				trace f.region.beginLine
				trace f.region.endLine
				#/
				if f.type == FoldType.Comment
					commentBlockCount += 1
					
			assert commentBlockCount == 3
		body
			if infoList.count < 2
				# not enough lines to create a fold
				return
	
			commentCloser as ClosesDelimitedBlock = do(i as LineInformation)
				return i.opensComment
	
			docStringCloser as ClosesDelimitedBlock = do(i as LineInformation)
				return i.opensDocString
	
			lineNumber = infoList.count
			curr as LineInformation? = infoList[lineNumber - 1]
	
			endStack = Stack<of TextLocation>()
			levelStack = Stack<of int>()
	
			# go through the list backwards creating folds as we go
			while curr <> nil
	
				closer as ClosesDelimitedBlock? = nil
	
				# skip blank lines
				while curr.isBlank
					curr = curr.previous
					if curr == nil
						return
					lineNumber -= 1
	
				# handle comment blocks and doc strings
				if curr.closesComment
					closer = commentCloser
				else if curr.closesDocString
					closer = docStringCloser
	
				if closer <> nil
					endLocation = TextLocation(lineNumber, curr.line.length + 1)
					
					if closer == docStringCloser
					
						level = _getIndentLevel(curr.line)
						#trace level
						
						if level > 0
							if levelStack.count == 0 or (levelStack.count > 0 and levelStack.peek < level)
								/# We need to make sure the doc string
								closes with its containing block #/
								levelStack.push(level)
								endStack.push(endLocation)
	
					# we won't have a line that closes a delimited block without one that opens it
					blockText = curr to !
					while not closer(blockText)
						blockText = blockText.previous to !
						lineNumber -= 1
	
					curr = blockText
					startLocation = TextLocation(lineNumber, curr.line.length + 2)
					folds.add(FoldingRegion(DomRegion(startLocation, endLocation), FoldType.Comment))
					curr = curr.previous
					lineNumber -= 1
					continue
		
				# handle indent blocks (ignore commented lines)
				if not curr.line.trimStart.startsWith("#")
				
					level = _getIndentLevel(curr.line)
					
					# should we close any regions?
					while levelStack.count > 0 and levelStack.peek > level
						levelStack.pop
						endLocation = endStack.pop
						startLocation = TextLocation(lineNumber, curr.line.length + 2)
						folds.add(FoldingRegion(DomRegion(startLocation, endLocation), FoldType.Undefined))
					
					# should we open any regions?
					if levelStack.count == 0
						first = 0
					else if level > levelStack.peek
						first = levelStack.peek
					else
						# makes the following loop do nothing
						first = level + 2
																	
					for l in first : level + 1
						levelStack.push(l)
						endStack.push(TextLocation(lineNumber, curr.line.length + 1))
	
				curr = curr.previous
				lineNumber -= 1


	def _getIndentLevel(line as String) as int
		"""
		Returns the number of indents for the given line.
		"""
		require
			line.trim.length > 0
		ensure
			result >= 0
		test
			assert Parser()._getIndentLevel("print 'hello'") == 0
			assert Parser()._getIndentLevel("\tprint 'hello'") == 1
			assert Parser()._getIndentLevel("\t\tprint 'hello'") == 2
		body
			return (line.length - line.trimStart.length) // _indentToken.length
